{"version":3,"sources":["../src/ts/complex.ts","../src/ts/utils.ts","../src/ts/julia.ts","../src/ts/main.ts"],"names":[],"mappings":"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","file":"main.2362fb91.js","sourceRoot":"../public","sourcesContent":["/**\r\n * Complex number class.\r\n *\r\n * @class Complex\r\n */\r\nclass Complex {\r\n    /**\r\n     * Creates an instance of Complex.\r\n     *\r\n     * @param {number} real Real part.\r\n     * @param {number} imaginary imaginary part.\r\n     * @memberof Complex\r\n     */\r\n    constructor(public real: number, public imaginary: number) {}\r\n\r\n    /**\r\n     * Returns the absolute value.\r\n     *\r\n     * @returns {number} Absolute value.\r\n     * @memberof Complex\r\n     */\r\n    public abs(): number {\r\n        return Math.sqrt(Math.pow(this.real, 2) + Math.pow(this.imaginary, 2));\r\n    }\r\n\r\n    /**\r\n     * Adds two complex numbers.\r\n     *\r\n     * @param {Complex} other Other complex number.\r\n     * @returns {Complex} Result number.\r\n     * @memberof Complex\r\n     */\r\n    public add(other: Complex): Complex {\r\n        return new Complex(this.real + other.real, this.imaginary + other.imaginary);\r\n    }\r\n\r\n    /**\r\n     * Multiplies two complex numbers.\r\n     *\r\n     * @param {Complex} other Other complex number.\r\n     * @returns {Complex} Result number.\r\n     * @memberof Complex\r\n     */\r\n    public mul(other: Complex): Complex {\r\n        return new Complex(\r\n            this.real * other.real - this.imaginary * other.imaginary,\r\n            this.real * other.imaginary + this.imaginary * other.real,\r\n        );\r\n    }\r\n}\r\n\r\nexport default Complex;\r\n","/**\r\n * Utility functions.\r\n *\r\n * @abstract\r\n * @class Utils\r\n */\r\nabstract class Utils {\r\n    /**\r\n     * Linear interpolation.\r\n     *\r\n     * @static\r\n     * @param {number} a Value A.\r\n     * @param {number} b Value B.\r\n     * @param {number} p Percentage to interpolate.\r\n     * @returns {number} Interpolated value.\r\n     * @memberof Utils\r\n     */\r\n    public static lerp(a: number, b: number, p: number): number {\r\n        return (1 - p) * a + p * b;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Canvas element.\r\n     *\r\n     * @static\r\n     * @param {number} width Canvas width.\r\n     * @param {number} height Canvas height.\r\n     * @returns {HTMLCanvasElement} Canvas element.\r\n     * @memberof Utils\r\n     */\r\n    public static canvas(width: number, height: number): HTMLCanvasElement {\r\n        const canvas = document.createElement<\"canvas\">(\"canvas\");\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n\r\n        document.body.append(canvas);\r\n\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * Builds a color gradient.\r\n     *\r\n     * @static\r\n     * @param {string} color1 Start color in hexadecimal.\r\n     * @param {string} color2 End color in hexadecimal.\r\n     * @param {number} steps Number of steps including base colors.\r\n     * @returns {string[]} Color gradient.\r\n     * @memberof Utils\r\n     */\r\n    public static gradient(color1: string, color2: string, steps: number): string[] {\r\n        steps = Math.floor(steps) - 2;\r\n\r\n        const colors: string[] = [];\r\n\r\n        colors.push(color1);\r\n\r\n        if (steps > 0) {\r\n            const r1 = color1.substr(0, 2);\r\n            const g1 = color1.substr(2, 2);\r\n            const b1 = color1.substr(4, 2);\r\n\r\n            const r2 = color2.substr(0, 2);\r\n            const g2 = color2.substr(2, 2);\r\n            const b2 = color2.substr(4, 2);\r\n\r\n            for (let i = 1; i <= steps; i++) {\r\n                const percentage = i / (steps + 2);\r\n\r\n                const r = Math.floor(Utils.lerp(Utils.dec(r1), Utils.dec(r2), percentage));\r\n                const g = Math.floor(Utils.lerp(Utils.dec(g1), Utils.dec(g2), percentage));\r\n                const b = Math.floor(Utils.lerp(Utils.dec(b1), Utils.dec(b2), percentage));\r\n\r\n                const color = Utils.hex(r) + Utils.hex(g) + Utils.hex(b);\r\n\r\n                colors.push(color);\r\n            }\r\n        }\r\n\r\n        colors.push(color2);\r\n\r\n        return colors;\r\n    }\r\n\r\n    /**\r\n     * Converts a hexadecimal number to a decimal one.\r\n     *\r\n     * @static\r\n     * @param {string} hex Hexadecimal number.\r\n     * @returns {number} Decimal number.\r\n     * @memberof Utils\r\n     */\r\n    public static dec(hex: string): number {\r\n        return parseInt(hex, 16);\r\n    }\r\n\r\n    /**\r\n     * Converts a decimal number to a hexadecimal one.\r\n     *\r\n     * @static\r\n     * @param {string} number Decimal number.\r\n     * @returns {number} Hexadecimal number.\r\n     * @memberof Utils\r\n     */\r\n    public static hex(dec: number): string {\r\n        return (\"0\" + dec.toString(16)).slice(-2);\r\n    }\r\n\r\n    /**\r\n     * Computes percentiles for an array.\r\n     *\r\n     * @static\r\n     * @param {number[]} array Array of numbers.\r\n     * @param {number[]} percentages Percentages.\r\n     * @returns {number[]} Percentiles.\r\n     * @memberof Utils\r\n     */\r\n    public static percentiles(array: number[], percentages: number[]): number[] {\r\n        const sorted = array.slice().sort((a, b) => (a > b ? 1 : -1));\r\n\r\n        const percentiles: number[] = [];\r\n\r\n        for (const percentage of percentages) {\r\n            const index = Math.floor((percentage / 100) * (sorted.length - 1));\r\n\r\n            percentiles.push(sorted[index]);\r\n        }\r\n\r\n        return percentiles;\r\n    }\r\n\r\n    /**\r\n     * Returns percentage steps.\r\n     *\r\n     * @static\r\n     * @param {number} count Count of steps.\r\n     * @returns {number[]} Percentage steps.\r\n     * @memberof Utils\r\n     */\r\n    public static percentages(count: number): number[] {\r\n        const data: number[] = [];\r\n\r\n        for (let i = 1; i <= count; i++) {\r\n            data.push((100 / count) * i);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns distinct numbers.\r\n     *\r\n     * @static\r\n     * @param {number[]} array Numbers.\r\n     * @returns {number[]} Distinct array.\r\n     * @memberof Utils\r\n     */\r\n    public static distinct(array: number[]): number[] {\r\n        const data: number[] = [];\r\n\r\n        for (const item of array) {\r\n            if (!data.includes(item)) {\r\n                data.push(item);\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Replaces a Canvas element by an Image element.\r\n     *\r\n     * @static\r\n     * @param {HTMLCanvasElement} canvas Canvas element.\r\n     * @returns {HTMLImageElement} Image element.\r\n     * @memberof Utils\r\n     */\r\n    public static image(canvas: HTMLCanvasElement): HTMLImageElement {\r\n        const image = document.createElement<\"img\">(\"img\");\r\n        image.src = canvas.toDataURL();\r\n\r\n        canvas.remove();\r\n\r\n        document.body.append(image);\r\n\r\n        return image;\r\n    }\r\n}\r\n\r\nexport default Utils;\r\n","import Complex from \"./complex\";\r\nimport Utils from \"./utils\";\r\n\r\n/**\r\n * Julia set fractal.\r\n *\r\n * @abstract\r\n * @class Julia\r\n */\r\nabstract class Julia {\r\n    /**\r\n     * Builds the Julia set fractal.\r\n     *\r\n     * @static\r\n     * @param {Complex} c C parameter.\r\n     * @param {number} iterations Max iteration count.\r\n     * @param {number} width Canvas width.\r\n     * @param {number} height Canvas height.\r\n     * @returns {number[]} Iteration count for each point.\r\n     * @memberof Julia\r\n     */\r\n    public static build(c: Complex, iterations: number, width: number, height: number): number[] {\r\n        const left = -2.5;\r\n        const right = 1.5;\r\n        const bottom = -1.5;\r\n        const top = 1.5;\r\n\r\n        const data: number[] = [];\r\n\r\n        for (let cy = 0; cy < height; cy++) {\r\n            for (let cx = 0; cx < width; cx++) {\r\n                const x = Utils.lerp(left, right, cx / width);\r\n                const y = Utils.lerp(bottom, top, cy / height);\r\n\r\n                const item = Julia.compute(c, x, y, iterations);\r\n\r\n                data.push(item);\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Computes the Julia set for a given position (not canvas coordinates).\r\n     *\r\n     * @private\r\n     * @static\r\n     * @param {Complex} c C parameter.\r\n     * @param {number} x X position.\r\n     * @param {number} y Y position.\r\n     * @param {number} iterations Max iteration count.\r\n     * @returns {number} Iteration count.\r\n     * @memberof Julia\r\n     */\r\n    private static compute(c: Complex, x: number, y: number, iterations: number): number {\r\n        let z = new Complex(x, y);\r\n        let i = 0;\r\n\r\n        while (z.abs() <= 2 && i < iterations) {\r\n            z = z.mul(z).add(c);\r\n            i++;\r\n        }\r\n\r\n        if (i === iterations) {\r\n            return -1;\r\n        } else {\r\n            return i;\r\n        }\r\n    }\r\n}\r\n\r\nexport default Julia;\r\n","import Complex from \"./complex\";\r\nimport Julia from \"./julia\";\r\nimport Utils from \"./utils\";\r\n\r\n// Fractal\r\nconst c = new Complex(0.285, 0.01);\r\nconst iterations = 1000;\r\nconst width = 1024;\r\nconst height = Math.floor((width * 2) / 3);\r\n\r\nconst data = Julia.build(c, iterations, width, height);\r\n\r\n// Colors\r\nconst color1 = \"039be5\"; // 600\r\nconst color2 = \"e1f5fe\"; // 050\r\nconst color3 = \"01579b\"; // 900\r\nconst steps = 1000;\r\n\r\nconst percentages = Utils.percentages(steps);\r\nconst percentiles = Utils.distinct(Utils.percentiles(data, percentages));\r\nconst colors = Utils.gradient(color1, color2, percentiles.length);\r\n\r\n// Rendering\r\nconst canvas = Utils.canvas(width, height);\r\nconst context = canvas.getContext(\"2d\");\r\n\r\nfor (let cy = 0; cy < height; cy++) {\r\n    for (let cx = 0; cx < width; cx++) {\r\n        const index = cy * width + cx;\r\n        const item = data[index];\r\n\r\n        if (item === -1) {\r\n            context.fillStyle = `#${color3}`;\r\n        } else {\r\n            const next = percentiles.findIndex((p) => item < p);\r\n            const step = next - 1;\r\n\r\n            const color = Math.min(Math.max(step, 0), colors.length - 1);\r\n\r\n            context.fillStyle = `#${colors[color]}`;\r\n        }\r\n\r\n        context.fillRect(cx, cy, 1, 1);\r\n    }\r\n}\r\n\r\n// View\r\n// Utils.image(canvas);\r\n"]}